double overlap = // really large value;
Axis smallest = null;
Axis[] axes1 = shape1.getAxes();
Axis[] axes2 = shape2.getAxes();
// loop over the axes1
for (int i = 0; i < axes1.length; i++) {
  Axis axis = axes1[i];
  // project both shapes onto the axis
  Projection p1 = shape1.project(axis);
  Projection p2 = shape2.project(axis);
  // do the projections overlap?
  if (!p1.overlap(p2)) {
    // then we can guarantee that the shapes do not overlap
    return false;
  } else {
    // get the overlap
    double o = p1.getOverlap(p2);
    // check for minimum
    if (o < overlap) {
      // then set this one as the smallest
      overlap = o;
      smallest = axis;
    }
  }
}
// Now exactly the same thing for the first object 
// ----


MTV mtv = new MTV(smallest, overlap);
// if we get here then we know that every axis had overlap on it
// so we can guarantee an intersection
return mtv;


// There has to be additional circle vs circle test and also  circle vs polygon can be done this way but need to consider the axis from cirlce center and polygon vertex closest to the circle


// For collisions - there are two approaches 

1) In each step, test all pairs of object for collisions
  - dummy n^2
  - optimizations: bounding boxes (for complex objects and polygons) -> convert to intervals -> sweep (n*log(n)) 

2) Prior - precompute all future collisions in n^2
  - create an event time-priority queue (in update method deque based on time)
  - separate 'draw' and 'update' operations - each update updates new values for only a pair of objects - taken O(n) time